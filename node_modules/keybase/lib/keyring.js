// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var E, GE, GpgKey, env, iced, k, keyring, log, v, __iced_k, __iced_k_noop, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  iced = require('iced-runtime').iced;
  __iced_k = __iced_k_noop = function() {};

  log = require('./log');

  env = require('./env').env;

  _ref = require('./err'), E = _ref.E, GE = _ref.GE;

  keyring = require('gpg-wrapper').keyring;

  GpgKey = (function(_super) {
    __extends(GpgKey, _super);

    function GpgKey() {
      return GpgKey.__super__.constructor.apply(this, arguments);
    }

    GpgKey.prototype.find = function(cb) {
      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/jacko/node-client/src/keyring.iced",
            funcname: "GpgKey.find"
          });
          GpgKey.__super__.find.call(_this, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 13
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          err = err == null ? null : err instanceof GE.NotFoundError ? new E.NoLocalKeyError((_this._is_self ? "You don't have a local " + (_this._secret ? 'secret' : 'public') + " key!" : "the user " + (_this.username()) + " doesn't have a local key")) : err instanceof GE.NoFingerprintError ? new E.NoRemoteKeyError((_this._is_self ? "You don't have a registered remote key! Try `keybase push`" : "the user " + (_this.username()) + " doesn't have a remote key")) : err;
          return cb(err);
        };
      })(this));
    };

    GpgKey.prototype.has_canonical_username = function() {
      var all_uids, e, em, uid;
      em = env().keybase_email();
      all_uids = this.all_uids();
      return (__indexOf.call((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = all_uids.length; _i < _len; _i++) {
          uid = all_uids[_i];
          if ((e = uid != null ? uid.email : void 0)) {
            _results.push(e);
          }
        }
        return _results;
      })(), em) >= 0);
    };

    GpgKey.prototype.get_ekid = function() {
      return this._ekid;
    };

    GpgKey.make_secret_from_user = function(_arg, cb) {
      var err, key_manager, keyring, secret_key_candidate, user, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      user = _arg.user, keyring = _arg.keyring;
      (function(_this) {
        return (function(__iced_k) {
          var _i, _len, _ref1, _results, _while;
          _ref1 = user.sibkeys;
          _len = _ref1.length;
          _i = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++_i;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(_i < _len)) {
              return _break();
            } else {
              key_manager = _ref1[_i];
              (function(__iced_k) {
                if (key_manager.get_type() !== 'pgp') {
                  (function(__iced_k) {
_continue()
                  })(__iced_k);
                } else {
                  return __iced_k();
                }
              })(function() {
                secret_key_candidate = _this._make_from_user_and_material({
                  user: user,
                  secret: true,
                  keyring: keyring,
                  bundle: key_manager.armored_pgp_public,
                  fingerprint: key_manager.get_pgp_fingerprint().toString('hex'),
                  ekid: key_manager.get_ekid()
                });
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/jacko/node-client/src/keyring.iced",
                    funcname: "GpgKey.make_secret_from_user"
                  });
                  secret_key_candidate.find(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return err = arguments[0];
                      };
                    })(),
                    lineno: 61
                  }));
                  __iced_deferrals._fulfill();
                })(function() {
                  if (typeof err === "undefined" || err === null) {
                    cb(null, secret_key_candidate);
                    return;
                  }
                  return _next();
                });
              });
            }
          };
          _while(__iced_k);
        });
      })(this)((function(_this) {
        return function() {
          return cb(new E.NoLocalKeyError("No GPG secret key available for user " + (user.username())));
        };
      })(this));
    };

    GpgKey.make_all_public_from_user = function(_arg) {
      var key_manager, keyring, keys, user, _i, _len, _ref1;
      user = _arg.user, keyring = _arg.keyring;
      keys = [];
      _ref1 = user.sibkeys;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        key_manager = _ref1[_i];
        if (key_manager.get_type() !== 'pgp') {
          continue;
        }
        keys.push(this._make_from_user_and_material({
          user: user,
          secret: false,
          keyring: keyring,
          bundle: key_manager.armored_pgp_public,
          fingerprint: key_manager.get_pgp_fingerprint().toString('hex'),
          ekid: key_manager.get_ekid()
        }));
      }
      return keys;
    };

    GpgKey._make_from_user_and_material = function(_arg) {
      var bundle, ekid, fingerprint, keyring, ret, secret, user;
      user = _arg.user, secret = _arg.secret, keyring = _arg.keyring, bundle = _arg.bundle, fingerprint = _arg.fingerprint, ekid = _arg.ekid;
      ret = new GpgKey({
        user: user,
        secret: secret,
        username: user.username(),
        is_self: user.is_self(),
        uid: user.id,
        key_data: bundle,
        keyring: keyring,
        fingerprint: fingerprint
      });
      ret._ekid = ekid;
      return ret;
    };

    return GpgKey;

  })(keyring.GpgKey);

  for (k in keyring) {
    v = keyring[k];
    exports[k] = v;
  }

  exports.BaseKeyRing.prototype.make_all_public_gpg_keys_from_user = function(_arg) {
    var user;
    user = _arg.user;
    return GpgKey.make_all_public_from_user({
      user: user,
      keyring: this
    });
  };

  exports.BaseKeyRing.prototype.make_secret_gpg_key_from_user = function(_arg, cb) {
    var user;
    user = _arg.user;
    return GpgKey.make_secret_from_user({
      user: user,
      keyring: this
    }, cb);
  };

  exports.init = function() {
    return keyring.init({
      get_preserve_tmp_keyring: function() {
        return env().get_preserve_tmp_keyring();
      },
      get_debug: function() {
        return env().get_debug();
      },
      get_tmp_keyring_dir: function() {
        return env().get_tmp_keyring_dir();
      },
      get_key_klass: function() {
        return GpgKey;
      },
      get_home_dir: function() {
        return env().get_home_gnupg_dir(true);
      },
      get_gpg_cmd: function() {
        return env().get_gpg_cmd();
      },
      get_no_options: function() {
        return env().get_no_gpg_options();
      },
      log: log
    });
  };

}).call(this);
